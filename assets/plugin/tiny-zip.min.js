/*! TinyZip (store-only) â€” zip(files) -> Promise<Blob>. files: [{name:string, blob|data|text}] */
!(function (w) {
    "use strict";
    function te(s) {
        return new TextEncoder().encode(s);
    }
    function u32(n) {
        return new Uint8Array([n & 255, (n >>> 8) & 255, (n >>> 16) & 255, (n >>> 24) & 255]);
    }
    function u16(n) {
        return new Uint8Array([n & 255, (n >>> 8) & 255]);
    }
    function concat(arrs) {
        let len = 0;
        for (const a of arrs) len += a.length;
        const out = new Uint8Array(len);
        let off = 0;
        for (const a of arrs) {
            out.set(a, off);
            off += a.length;
        }
        return out;
    }
    function toDosTimeDate(d) {
        const t = d || new Date();
        const sec = Math.floor(t.getSeconds() / 2),
            min = t.getMinutes(),
            hr = t.getHours();
        const day = t.getDate(),
            mon = t.getMonth() + 1,
            yr = t.getFullYear() - 1980;
        const dosTime = (hr << 11) | (min << 5) | sec;
        const dosDate = (yr << 9) | (mon << 5) | day;
        return { dosTime, dosDate };
    }
    function crc32(buf) {
        let c = ~0 >>> 0;
        for (let i = 0; i < buf.length; i++) {
            c = (c >>> 8) ^ T[(c ^ buf[i]) & 255];
        }
        return ~c >>> 0;
    }
    const T = (function () {
        let t = [];
        for (let n = 0; n < 256; n++) {
            let c = n;
            for (let k = 0; k < 8; k++) c = c & 1 ? 3988292384 ^ (c >>> 1) : c >>> 1;
            t[n] = c >>> 0;
        }
        return t;
    })();
    async function readFile(f) {
        if (f == null) return new Uint8Array(0);
        if (f instanceof Blob) {
            const ab = await f.arrayBuffer();
            return new Uint8Array(ab);
        }
        if (f instanceof Uint8Array) return f;
        if (typeof f === "string") return te(f);
        return te(String(f));
    }
    async function zip(files) {
        const parts = [];
        const central = [];
        let offset = 0;
        const now = toDosTimeDate(new Date());
        for (const file of files) {
            const name = String(file.name || "file.bin");
            const nameBytes = te(name);
            const data = await readFile(file.blob || file.data || file.text);
            const crc = crc32(data);
            const comp = data;
            const compSize = comp.length,
                uncompSize = data.length;
            const sigLF = u32(0x04034b50),
                ver = u16(20),
                flag = u16(0),
                method = u16(0),
                time = u16(now.dosTime),
                date = u16(now.dosDate),
                crcA = u32(crc),
                csize = u32(compSize),
                usize = u32(uncompSize),
                nlen = u16(nameBytes.length),
                xlen = u16(0);
            const localHeader = concat([
                sigLF,
                ver,
                flag,
                method,
                time,
                date,
                crcA,
                csize,
                usize,
                nlen,
                xlen,
                nameBytes,
            ]);
            parts.push(localHeader, comp);
            const localOffset = offset;
            offset += localHeader.length + comp.length;
            const sigCD = u32(0x02014b50),
                verMade = u16(20),
                verNeed = u16(20),
                gpFlag = u16(0),
                cm = u16(0),
                tm = u16(now.dosTime),
                dt = u16(now.dosDate),
                crcC = u32(crc),
                cs = u32(compSize),
                us = u32(uncompSize),
                fnl = u16(nameBytes.length),
                efl = u16(0),
                coml = u16(0),
                disk = u16(0),
                iattr = u16(0),
                eattr = u32(0),
                reloff = u32(localOffset);
            const cdHdr = concat([
                sigCD,
                verMade,
                verNeed,
                gpFlag,
                cm,
                tm,
                dt,
                crcC,
                cs,
                us,
                fnl,
                efl,
                coml,
                disk,
                iattr,
                eattr,
                reloff,
                nameBytes,
            ]);
            central.push(cdHdr);
        }
        const centralDir = concat(central);
        const sigEOCD = u32(0x06054b50),
            diskNum = u16(0),
            startDisk = u16(0),
            entriesDisk = u16(central.length),
            entriesTot = u16(central.length),
            cdSize = u32(centralDir.length),
            cdOff = u32(offset),
            cmntLen = u16(0);
        const eocd = concat([sigEOCD, diskNum, startDisk, entriesDisk, entriesTot, cdSize, cdOff, cmntLen]);
        const out = concat([...parts, centralDir, eocd]);
        return new Blob([out], { type: "application/zip" });
    }
    w.TinyZip = { zip: zip };
})(window);
